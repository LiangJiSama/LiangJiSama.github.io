<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>LiangJiSama Offical</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
  <meta property="og:type" content="website">
<meta property="og:title" content="LiangJiSama Offical">
<meta property="og:url" content="http://liangjisama.top/index.html">
<meta property="og:site_name" content="LiangJiSama Offical">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kagamine Len">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css?v=233" crossorigin>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css">
  
  <link rel="stylesheet" href="/css/style.css?v=1620228345809">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Kagamine Len" class="mdui-btn mdui-btn-icon"><img src="https://i.loli.net/2021/04/27/ZAib7wdrOfgCsBl.jpg" alt="Kagamine Len"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Kagamine Len">
            <img src="https://i.loli.net/2021/04/27/ZAib7wdrOfgCsBl.jpg" alt="Kagamine Len" alt="Kagamine Len">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>11</div>
        <div><span>标签</span>7</div>
        <div><span>分类</span>1</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:liangjisama.top" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://github.com/LiangJiSama" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/笔记/">笔记</a>
          <span class="category-list-count">11</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/unity/" style="font-size: 10px;">unity</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 10px;">数据结构与算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机组成原理</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 Kagamine Len
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2021/05/05/%E5%A0%86%E6%8E%92%E5%BA%8F/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="堆排序" class="lazyload">
                    <h1>堆排序</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>546 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
        </div>

        <article>
            
                <p>堆排序的过程为</p>
<p>建堆 从最后一个非叶子节点（对于节点编号为0~n-1的树，最后一个非叶子节点为n/2-1)，按照堆的定义调整堆（即选择当前这个节点两个儿子节点(i*2+1,i*2+2)中的最大值，然后交换当前节点和该最大值节点）</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/05/05/C-%E4%B8%ADstatic%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E9%97%B4/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="C++中static的初始化时间" class="lazyload">
                    <h1>C++中static的初始化时间</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>667 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
        </div>

        <article>
            
                <p>本次上传主要是关于静态局部变量的初始化问题。</p>
<p>首先，静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/05/05/c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="c++编译过程" class="lazyload">
                    <h1>c++编译过程</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>2.4k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 10 分钟</a>
        </div>

        <article>
            
                <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> <strong>C和C++编译器是集成的，编译一般分为四个步骤：</strong></p>
<ol>
<li><strong>预处理(preprocessing)  —————– cpp/ gcc -E</strong> </li>
<li><strong>编译(compilation) —————— cc1 / gcc -S</strong></li>
<li><strong>汇编(assembly)  ——————– as</strong></li>
<li><strong>连接(linking) ——————— ld</strong> </li>
</ol>
<ol start="2">
<li>动态链接</li>
</ol>
<p>在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。</p>
<p>对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。</p>
<p>ps:详见深入理解操作系统</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/05/05/%E9%9D%A2%E8%AF%95%E5%8F%91%E7%8E%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BC%BA%E5%A4%B1/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="面试发现的知识点缺失" class="lazyload">
                    <h1>面试发现的知识点缺失</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>105 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>TCP拥塞控制</p>
<p>七层协议</p>
<h1 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h1><p>光线追踪的朴素实现</p>
<p>渲染管线（坐标变换的过程）</p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>c++的编译过程：有待进一步研究</p>
<p><del>static的初始化时间</del></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>B+树</p>
<p>红黑树</p>
<p><del>大根堆的实现</del></p>
<p>最小生成树</p>
<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><p>动作机中的Blend是什么？</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>测试中的TPS和QPS分别指的是什么</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/05/05/const%E5%85%B3%E9%94%AE%E5%AD%97/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="const关键字" class="lazyload">
                    <h1>const关键字</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>420 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
        </div>

        <article>
            
                <h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://i.loli.net/2021/05/05/1bgfwK4k6L8NQih.png" alt="image-20210505101147641" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://i.loli.net/2021/05/05/xDVqtyUKiZajMCs.png" alt="image-20210505101344643" class="lazyload"></p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/04/29/unity%E5%90%84%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="unity各个事件的调用顺序" class="lazyload">
                    <h1>unity各个事件的调用顺序</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年04月29日</a>
            <a><i class="nexmoefont icon-areachart"></i>679 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
        </div>

        <article>
            
                <p><img data-fancybox="gallery" data-sizes="auto" data-src="https://docs.unity3d.com/cn/2019.4/uploads/Main/monobehaviour_flowchart.svg" alt="img" class="lazyload"></p>
<p>由图可见，unity为了保证fixedupdate的可靠性，就算在update中一次更新是十分缓慢的，但在fixedupdate中会循环执行直到当前fixedupdate能够执行到的时间与当前的时间相吻合。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/04/29/%E7%88%B6%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB%E7%9A%84%E5%90%84%E7%A7%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="父类与子类的各种构造函数的调用关系" class="lazyload">
                    <h1>父类与子类的各种构造函数的调用关系</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年04月29日</a>
            <a><i class="nexmoefont icon-areachart"></i>255 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>Attention:</p>
<p>C++的初始化 base b=b(); or base b;调用的是构造函数 base d=b;仍然是一个对d的构造 因此应该调用拷贝构造函数而非拷贝赋值运算符</p>
<p>对于移动构造函数的情况间下列代码：</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/04/28/shareptr/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="shareptr" class="lazyload">
                    <h1>shareptr</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年04月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>881 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 4 分钟</a>
        </div>

        <article>
            
                <p><img data-fancybox="gallery" data-sizes="auto" data-src="https://i.loli.net/2021/04/29/416mdcYxwj2KuvB.png" alt="image-20210429220617927" class="lazyload"></p>
<h2 id="为什么使用std-make-shared"><a href="#为什么使用std-make-shared" class="headerlink" title="为什么使用std::make_shared"></a>为什么使用std::make_shared</h2><p>std::shared_ptr是常用的智能指针，建立一个shared_ptr对象有两种方式：</p>
<pre><code class="c++">// (1)
std::shared_ptr&lt;Widget&gt; p1(new Widget);
// (2)
std::shared_ptr&lt;Widget&gt; p2(std::make_shared&lt;Widget&gt;());
</code></pre>
<p>通常方法（2）使用make_shared是更受推荐的做法。原因是</p>
<h2 id="减少重复代码"><a href="#减少重复代码" class="headerlink" title="减少重复代码"></a>减少重复代码</h2><p>对于</p>
<pre><code class="c++">// (2)
std::shared_ptr&lt;Widget&gt; p2(std::make_shared&lt;Widget&gt;());
</code></pre>
<p>它可以简化为</p>
<pre><code class="c++">// (2)
auto p2(std::make_shared&lt;Widget&gt;());
</code></pre>
<p>对比(1)少书写了一次Widget，在代码中减少重复总是一件好事，对吧:)</p>
<h2 id="效率更高"><a href="#效率更高" class="headerlink" title="效率更高"></a>效率更高</h2><p>对于</p>
<pre><code class="c++">// (1)
std::shared_ptr&lt;Widget&gt; p1(new Widget);
</code></pre>
<p>存在两次内存分配操作：<br> 1.new Widget<br> 2.为p1分配控制块（control block），控制块用于存放引用计数等信息<br> 而对于</p>
<pre><code class="c++">// (2)
auto p2(std::make_shared&lt;Widget&gt;());
</code></pre>
<p>只有一次内存内配操作，make_shared会一次性申请足够大的空间用于存放Widget对象和智能指针的控制块。<br> 在MSVC版本的STL中，make_shared的实现是</p>
<pre><code class="c++">template&lt;class _Ty,
    class... _Types&gt; inline
        shared_ptr&lt;_Ty&gt; make_shared(_Types&amp;&amp;... _Args)
    &#123;    // make a shared_ptr
    _Ref_count_obj&lt;_Ty&gt; *_Rx =
        new _Ref_count_obj&lt;_Ty&gt;(_STD forward&lt;_Types&gt;(_Args)...);

    shared_ptr&lt;_Ty&gt; _Ret;
    _Ret._Resetp0(_Rx-&gt;_Getptr(), _Rx);
    return (_Ret);
    &#125;
</code></pre>
<p>这里的_Ref_count_obj类包含成员变量：<br> 1.控制块<br> 2.一个内存块，用于存放智能指针管理的资源对象<br> 所以new _Ref_count_obj能一次性为控制块和资源对象申请内存。<br> 感兴趣的读者可以再看看_Ref_count_obj的构造函数：</p>
<pre><code class="c++">template&lt;class... _Types&gt;
    _Ref_count_obj(_Types&amp;&amp;... _Args)
    : _Ref_count_base()
    &#123;    // construct from argument list
    ::new ((void *)&amp;_Storage) _Ty(_STD forward&lt;_Types&gt;(_Args)...);
    &#125;
</code></pre>
<p>此处其实也有一个new操作，但是是placement new，不涉及内存分配。所以内存分配操作还是只有一次。<br> 引用计数在_Ref_count_obj的父类_Ref_count_base中。而_Storage就是存放资源对象的内存块。_</p>
<p><em>placement new 会在已经开辟的空间中存放这个sotrage对象，即把对象放在指定的空间位置</em><br> 那_Storage是怎么来的？它其实是一个联合体，编译器在编译时能获取到资源对象的大小，然后利用模板实例化出具有相等大小的联合体或结构体，这个联合体或结构体的对象就可以用于存放资源对象。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://i.loli.net/2021/04/29/5OjNR8Wa2lGHxXK.png" alt="image-20210429222958679" class="lazyload"></p>
<h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://i.loli.net/2021/04/29/FzufkYTaVjehvCp.png" alt="image-20210429223330843" class="lazyload"></p>
<p>此处，unique_ptr采用了移动拷贝构造，虽然其普通拷贝构造是允许的，但是右值拷贝构造是允许的，因为编译器知道当前拷贝的这个对象将会被销毁，因此其仍然会调用该拷贝函数</p>
<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://i.loli.net/2021/04/29/BS9JzYjKe5OPbHl.png" alt="image-20210429223525254" class="lazyload"></p>
<p>如 函数返回的值为右值，nullptr为字面量为右值</p>
<p>函数返回引用时返回的为左值</p>
<h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><pre><code class="c++">      _Atomic_word  _M_use_count;     // #shared
      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)
</code></pre>
<p>由上述代码可见，实际上share_ptr和weak_ptr上都有指向一个计数类，包括对share_ptr的计数和对weak_ptr+(#shared!=0)的计数</p>
<p>即对于weak的计数来说，就算没有任何weak_ptr，其初始化值仍为1</p>
<p>那么weak_ptr什么时候判断share==0了呢？</p>
<pre><code class="c++">if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)
      &#123;
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);
        _M_dispose();
        // There must be a memory barrier between dispose() and destroy()
        // to ensure that the effects of dispose() are observed in the
        // thread that runs destroy().
        // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html
        if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)
          &#123;
        __atomic_thread_fence (__ATOMIC_ACQ_REL);
          &#125;

            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);
        if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,
                               -1) == 1)//此处 当share_ptr被释放时，会检测有无weak_ptr对象仍然引用了该计数，如果没有了，才会释放该计数器
              &#123;
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);
            _M_destroy();
              &#125;
      &#125;
      &#125;
</code></pre>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/04/27/file%20IO%20and%20virtual%20memory/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="文件读写及虚存访问" class="lazyload">
                    <h1>文件读写及虚存访问</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年04月27日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.7k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 7 分钟</a>
        </div>

        <article>
            
                <h1 id="虚拟缓存"><a href="#虚拟缓存" class="headerlink" title="虚拟缓存"></a>虚拟缓存</h1><h2 id="虚存的最大大小"><a href="#虚存的最大大小" class="headerlink" title="虚存的最大大小"></a>虚存的最大大小</h2><p>虚拟内存不受计算机中内存指针大小的限制，虚拟内存限制与寻址内存空间不同。可以解决的虚拟内存比使用分页的基于指针的地址空间中可用的虚拟内存更多</p>
<p>虚拟内存上限由操作系统设置：例如 32位Windows的限制为16TB，而在64位Windows上的限制为256TB。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/04/27/NF/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 50%;"> 
                    <img data-src="https://i.loli.net/2021/04/27/lVnTj5pPwD4GAyE.jpg" data-sizes="auto" alt="范式" class="lazyload">
                    <h1>范式</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow-fill">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年04月27日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
        </div>

        <article>
            
                <h1 id="1-第一范式（1NF）"><a href="#1-第一范式（1NF）" class="headerlink" title="1. 第一范式（1NF）"></a>1. 第一范式（1NF）</h1><p>符合1NF的关系（你可以理解为数据表。“关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。<strong>1NF的定义为：符合1NF的关系中的每个属性都不可再分</strong>。<code>表1</code>所示的情况，就不符合1NF的要求。</p>
            
        </article>
    </div>
    
</section>

    <nav class="nexmoe-page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="nexmoefont icon-right"></i></a>
    </nav>
  
        <!--<div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool">
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>-->
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script>
	hljs.initHighlightingOnLoad();
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>
 

<script src="/js/app.js?v=1620228345809"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





</body>

</html>
